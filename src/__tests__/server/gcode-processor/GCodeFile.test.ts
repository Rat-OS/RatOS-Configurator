/* eslint-disable no-console */
/**
 * @file GCodeFile.test.ts
 * @description
 *
 * @author Tom Glastonbury <t@tg73.net>
 * @license MIT
 * @copyright 2024
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import { describe, test, expect } from 'vitest';
import { GCodeFlavour } from '@/server/gcode-processor/GCodeFlavour';
import semver, { SemVer } from 'semver';
import path from 'path';
import { GCodeFile } from '@/server/gcode-processor/GCodeFile';
import { Printability } from '@/server/gcode-processor/Printability';

const defaultExpectedInfo = {
	ratosDialectVersion: undefined,
	postProcessorVersion: undefined,
	postProcessorTimestamp: undefined,
	fileFormatVersion: undefined,
	isProcessedValue: false,
	processedForIdex: undefined,
	analysisResult: undefined,
	ratosMetaFileOffset: undefined,
};

const defaultExpectedFile = {
	canDeprocess: undefined,
	printability: undefined,
	printabilityReasons: [],
	info: defaultExpectedInfo,
};

describe('tryParseHeader', async () => {
	test.each([
		[
			'PrusaSlicer 2.8.0',
			'; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC\n\n',
			{
				...defaultExpectedInfo,
				flavour: GCodeFlavour.PrusaSlicer,
				generator: 'PrusaSlicer',
				generatorTimestamp: new Date('2024-09-06 08:32:07 UTC'),
				generatorVersion: semver.coerce('2.8.0+win64'),
			},
		],
		[
			'SuperSlicer 2.5.59.13',
			'; generated by SuperSlicer 2.5.59.13 on 2024-09-14 at 09:35:09 UTC\n\n',
			{
				...defaultExpectedInfo,
				flavour: GCodeFlavour.SuperSlicer,
				generator: 'SuperSlicer',
				generatorTimestamp: new Date('2024-09-14 09:35:09 UTC'),
				generatorVersion: semver.coerce('2.5.59.13'),
			},
		],
		[
			'OrcaSlicer 2.1.1',
			'; HEADER_BLOCK_START\n' +
				'; generated by OrcaSlicer 2.1.1 on 2024-09-12 at 14:57:24\n' +
				'; total layer number: 240',
			{
				...defaultExpectedInfo,
				flavour: GCodeFlavour.OrcaSlicer,
				generator: 'OrcaSlicer',
				generatorTimestamp: new Date('2024-09-12 14:57:24'),
				generatorVersion: semver.coerce('2.1.1'),
			},
		],
		[
			'CustomGenerator in RatOS dialect',
			'; generated by CustomGenerator 0.1-alpha in RatOS dialect 0.1 on 2025-01-01 at 08:32:07 UTC\n\n',
			{
				...defaultExpectedInfo,
				flavour: GCodeFlavour.RatOS,
				generator: 'CustomGenerator',
				generatorTimestamp: new Date('2025-01-01 08:32:07 UTC'),
				generatorVersion: semver.coerce('0.1-alpha'),
				ratosDialectVersion: semver.coerce('0.1'),
			},
		],
		[
			'CustomGenerator without RatOS dialect',
			'; generated by CustomGenerator 0.1-alpha on 2025-01-01 at 08:32:07 UTC\n\n',
			{
				...defaultExpectedInfo,
				flavour: GCodeFlavour.Unknown,
				generator: 'CustomGenerator',
				generatorTimestamp: new Date('2025-01-01 08:32:07 UTC'),
				generatorVersion: semver.coerce('0.1-alpha'),
			},
		],
		[
			'already processed, format v1',
			'; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC\n' +
				'; processed by RatOS 2.0.2-518-g4ffef464 on 2025-01-01 at 08:30:00Z\n',
			{
				...defaultExpectedInfo,
				fileFormatVersion: 1,
				flavour: GCodeFlavour.PrusaSlicer,
				generator: 'PrusaSlicer',
				generatorTimestamp: new Date('2024-09-06 08:32:07 UTC'),
				generatorVersion: semver.coerce('2.8.0+win64'),
				postProcessorVersion: semver.coerce('2.0.2-518-g4ffef464'),
				postProcessorTimestamp: new Date('2025-01-01 08:30:00Z'),
				isProcessedValue: true,
			},
		],
		['no match', 'blah blah blah', null],
	])('%s', (name, header, expected) => {
		const gci = GCodeFile.tryParseHeader(header);
		if (!expected) {
			expect(gci).toStrictEqual(expected);
		} else {
			const test = { ...gci, isProcessedValue: gci?.isProcessed };
			expect(test).toMatchObject(expected);
		}
	});

	test('getProcessedByRatosHeader', async () => {
		let header = GCodeFile.getProcessedByRatosHeader({
			currentCodeVersion: new SemVer('1.2.3'),
			timestamp: new Date(0xbadbabe),
			ratosMetaFileOffset: 0xdecafbad,
			processedForIdex: false,
		});
		expect(header).toEqual('; processed by RatOS.PostProcessor 1.2.3 on 1970-01-03 at 06:25:34 UTC v:3 m:decafbad');

		header = GCodeFile.getProcessedByRatosHeader({
			currentCodeVersion: new SemVer('1.2.3'),
			timestamp: new Date(0xbadbabe),
			ratosMetaFileOffset: 0xdecafbad,
			processedForIdex: true,
		});
		expect(header).toEqual(
			'; processed by RatOS.PostProcessor 1.2.3 on 1970-01-03 at 06:25:34 UTC v:3 m:decafbad idex',
		);
	});
});

describe('inspect', async () => {
	const defaultExpected = {
		canDeprocess: undefined,
		printability: undefined,
		printabilityReasons: [],
		info: {
			ratosDialectVersion: undefined,
			postProcessorVersion: undefined,
			postProcessorTimestamp: undefined,
			fileFormatVersion: undefined,
			isProcessedValue: false,
			processedForIdex: undefined,
			analysisResult: undefined,
			ratosMetaFileOffset: undefined,
		},
	};
	test.each([
		[
			'unprocessed valid, for idex',
			path.join(__dirname, 'fixtures', 'slicer_output', '001', 'SS_IDEX_MultiColor_WipeTower.gcode'),
			{
				...defaultExpectedFile,
				printability: Printability.MUST_PROCESS,
				info: {
					...defaultExpectedInfo,
					flavour: GCodeFlavour.SuperSlicer,
					generator: 'SuperSlicer',
					generatorTimestamp: new Date('2024-10-31T03:29:37.000Z'),
					generatorVersion: semver.coerce('2.5.60'),
				},
			},
			{ printerHasIdex: true },
		],
		[
			'unprocessed valid, not for idex',
			path.join(__dirname, 'fixtures', 'slicer_output', '001', 'SS_IDEX_MultiColor_WipeTower.gcode'),
			{
				...defaultExpectedFile,
				printability: Printability.READY,
				info: {
					...defaultExpectedInfo,
					flavour: GCodeFlavour.SuperSlicer,
					generator: 'SuperSlicer',
					generatorTimestamp: new Date('2024-10-31T03:29:37.000Z'),
					generatorVersion: semver.coerce('2.5.60'),
				},
			},
		],
		[
			'legacy processed',
			path.join(__dirname, 'fixtures', 'other', 'legacy_processed.gcode'),
			{
				...defaultExpectedFile,
				printability: Printability.NOT_SUPPORTED,
				printabilityReasons: [
					expect.stringContaining('The file format is from an old version of RatOS which is no longer supported'),
				],
				info: {
					...defaultExpectedInfo,
					fileFormatVersion: 0,
					flavour: GCodeFlavour.SuperSlicer,
					generator: 'SuperSlicer',
					generatorTimestamp: new Date('2024-10-31T03:29:37.000Z'),
					generatorVersion: semver.coerce('2.5.60'),
					postProcessorVersion: new SemVer('0.1.0-legacy'),
					isProcessedValue: true,
				},
			},
		],
		[
			'without ratos_meta block, format v3',
			path.join(__dirname, 'fixtures', 'other', 'without_ratos_meta.gcode'),
			{},
			{ expectedWarnings: ['INVALID_METADATA: The ratos_meta block was not found.'] },
		],
		[
			'without ratos_meta begin, format v3',
			path.join(__dirname, 'fixtures', 'other', 'without_ratos_meta_begin.gcode'),
			{},
			{ expectedWarnings: ['INVALID_METADATA: Failed to parse ratos_meta block: the begin marker was not found.'] },
		],
		[
			'wrong ratos_meta data length, format v3',
			path.join(__dirname, 'fixtures', 'other', 'ratos_meta_wrong_data_length.gcode'),
			{},
			{
				expectedWarnings: [
					'INVALID_METADATA: Failed to parse ratos_meta block: expected 999 base64 characters, but found 34.',
				],
			},
		],
	])('%s', async (name, path, expected, opts?: { printerHasIdex?: boolean; expectedWarnings?: any[] }) => {
		const warnings: string[] = [];
		const gcf = await GCodeFile.inspect(path, {
			printerHasIdex: !!opts?.printerHasIdex,
			onWarning: (c, m) => {
				const msg = `${c}: ${m}`;
				warnings.push(msg);
				//console.log(msg);
			},
		});

		if (gcf.info) {
			const test = { ...gcf, info: { ...gcf.info, isProcessedValue: gcf.info?.isProcessed } };
			expect(test).toMatchObject(expected);
		} else {
			expect(gcf).toMatchObject(expected);
		}

		expect(warnings).toMatchObject(opts?.expectedWarnings ?? []);
	});
});
